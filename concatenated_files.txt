/* --- Start of ./src/githubClient.ts --- */
import { Octokit } from '@octokit/rest';
import simpleGit from 'simple-git';
import { prompt } from './prompt';
import { cosmiconfigSync } from 'cosmiconfig';
import OpenAI from 'openai';
import { openUrl } from './openWrapper'; // Import the openUrl function
import { ChildProcess } from 'child_process';
import { execSync } from 'child_process';


export class GitHubClient {
    async listPulls(owner: string, repo: string, base: string, head: string): Promise<any>  {
        throw new Error("Not implemented");
    }

    async updatePull(owner: string, repo: string, pull_number: number, title: string, body: string) {
        throw new Error("Not implemented");
    }

    async createPull(owner: string, repo: string, base: string, head: string, title: string, body: string): Promise<any>  {
        throw new Error("Not implemented");
    }
}

export class OctokitClient extends GitHubClient {
    octokit: any;

    constructor(githubToken: string) {
        super();
        this.octokit = new Octokit({ auth: githubToken });
    }

    async listPulls(owner: string, repo: string, base: string, head: string): Promise<any>  {
        return this.octokit.pulls.list({ owner, repo, base, head });
    }

    async updatePull(owner: string, repo: string, pull_number: number, title: string, body: string) {
        return this.octokit.pulls.update({ owner, repo, pull_number, title, body });
    }

    async createPull(owner: string, repo: string, base: string, head: string, title: string, body: string): Promise<any>  {
        return this.octokit.pulls.create({ owner, repo, base, head, title, body });
    }
}

export class GhClient extends GitHubClient {
    async listPulls(owner: string, repo: string, base: string, head: string): Promise<any> {
        const result = execSync(`gh pr list --repo ${owner}/${repo} --base ${base} --head ${head} --json number`).toString();
        return JSON.parse(result);
    }

    async updatePull(owner: string, repo: string, pull_number: number, title: string, body: string) {
        execSync(`gh pr edit ${pull_number} --repo ${owner}/${repo} --title "${title}" --body "${body}"`);
    }

    async createPull(owner: string, repo: string, base: string, head: string, title: string, body: string): Promise<any>  {
        const result = execSync(`gh pr create --repo ${owner}/${repo} --base ${base} --head ${head} --title "${title}" --body "${body}" --json url`).toString();
        return JSON.parse(result);
    }
}/* --- End of ./src/githubClient.ts --- */

/* --- Start of ./src/prompt.ts --- */
export const prompt = `You will be asked to write a concise GitHub PR description based on a provided git diff. Analyze the code changes and provide a concise explanation of the changes, their context and why they were made. Do not treat imports and requires as changes or new features. Be very specific with the title, and be as concise as possible. Reference code, classes, functions, files, etc. as necessary to clarify the purpose of the commit or the changes involved. If the provided message is not a diff respond with an appropriate message. Don't surround your description in backticks but still write GitHub supported markdown. The answer should only include the text of the PR. Don't include starting or ending text because the response will be directly copied into the PR. Be brief and concise. Here is an example of the pull request template. Make sure to write a clear title. The title is required. Title must start with a # and end with two \\n's so that it is clearly separated from the rest of the body.\r\n\r\n----\r\n[build,chore,ci,docs,feat,fix,perf,refactor,style,test]: <TITLE GOES HERE>\r\n\r\n### Summary\r\n\r\n**Type:** [build,chore,ci,cicd,docs,feat,fix,perf,refactor,style,test] (Pick one only and start your PR title with it. Like 'feat: Adds a new widget')\r\n\r\n* **What kind of change does this PR introduce?** (Bug fix, feature, docs update, ...)\r\n\r\n* **What is the current behavior?** \r\n  * (You can also link to an open issue here)\r\n\r\n* **What is the new behavior?**\r\n  * (if this is a feature change)?\r\n\r\n* **Does this PR introduce a breaking change?** \r\n  * (What changes might users need to make in their application due to this PR?)\r\n\r\n* **Has Testing been included for this PR?\r\n  * description of testing if any\r\n\r\n### Other Information\r\n\r\nIf there's anything else that's important and relevant to your pull request, mention that information here. This could include benchmarks, or other information.\r\n----\r\n\r\nFor the list of commit types (build,chore,ci,docs,feat,fix,perf,refactor,style,test), here are explanations of each to help you identify the right tag, ordered from highest priority to lowest. If there are multiple purposes in a PR, choose the one higher on this list.\r\n\r\n1. feat: A new feature\r\n1. fix: A bug fix\r\n1. ci: Changes to our CI configuration files and scripts (like .github workflow files, release-it config, etc.)\r\n1. build: Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)\r\n1. perf: A code change that improves performance\r\n1. refactor: A code change that neither fixes a bug nor adds a feature, but reorganizes code.\r\n1. test: Adding missing tests or correcting existing tests\r\n1. style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)\r\n1. docs: Documentation only changes\r\n\r\n\r\nHere is the diff:\r\n`/* --- End of ./src/prompt.ts --- */

/* --- Start of ./src/openWrapper.ts --- */
import { ChildProcess } from 'child_process';

export async function openUrl(url: string): Promise<ChildProcess> {
    const { default: open } = await import('open');
    return open(url);
}
/* --- End of ./src/openWrapper.ts --- */

/* --- Start of ./src/index.ts --- */
import { Octokit } from '@octokit/rest';
import simpleGit from 'simple-git';
import { prompt } from './prompt';
import { cosmiconfigSync } from 'cosmiconfig';
import OpenAI from 'openai';
import { openUrl } from './openWrapper'; // Import the openUrl function
import { ChildProcess } from 'child_process';
import { execSync } from 'child_process';
import { GitHubClient, OctokitClient, GhClient } from './githubClient';

const defaultExclusions = [
    ":(exclude)**/package-lock.json",
    ":(exclude)**/pnpm-lock.yaml",
    ":(exclude)**/yarn.lock",
    ":(exclude)**/*.jpg",
    ":(exclude)**/*.jpeg",
    ":(exclude)**/*.png",
    ":(exclude)**/*.gif",
    ":(exclude)**/*.bmp",
    ":(exclude)**/*.tiff",
    ":(exclude)**/*.svg",
    ":(exclude)**/*.pdf"
];


export class PrBot {
    openaiApiKey: string;
    githubToken: string;
    gitHubClient: GitHubClient;
    exclusions: string[];
    openai: any;
    git: any;

    constructor(openaiApiKey: string, githubToken: string) {
        this.openaiApiKey = openaiApiKey;
        if (!this.openaiApiKey) {
            throw new Error("Error: OPENAI_API_KEY is not set");
        }

        this.githubToken = githubToken;
        if (!this.githubToken) {
            throw new Error("Error: GITHUB_TOKEN is not set");
        }

        this.gitHubClient = this.isGhCliAvailable() ? new GhClient() : new OctokitClient(this.githubToken);

        const explorer = cosmiconfigSync('prbot');
        const config = explorer.search();
        this.exclusions = config?.config?.exclusions || defaultExclusions;
        this.openai = new OpenAI({
            apiKey: this.openaiApiKey
        });
        this.git = simpleGit();
    }

    isGhCliAvailable() {
        try {
            execSync('gh auth status');
            return true;
        } catch {
            return false;
        }
    }

    async openUrl(url: string): Promise<ChildProcess> {
        if (!url) {
            console.error("Error: Please provide a value for the argument.");
            throw new Error("Error: URL is required");
        }
        try {
            return await openUrl(url); // Call the imported function
        } catch (error: any) {
            console.error(`Error opening URL: ${error.message}`);
            throw error;
        }
    }

    async createPr(baseBranch = 'develop', compareBranch?: string) {
        try {
            compareBranch = compareBranch || (await this.git.revparse(['--abbrev-ref', 'HEAD'])).trim() as string;
            console.log(`Comparing branches: ${baseBranch} and ${compareBranch}`);

            const prBody = await this.differ(baseBranch, compareBranch);
            if (!prBody) {
                console.error("Error: PR body could not be retrieved.");
                return;
            }
            const prTitle = prBody.split('\n')[0].replace(/^# /, '');

            if (!prTitle) {
                console.error("Error: PR title could not be extracted from the PR body.");
                return;
            }

            const repoInfo = await this.getRepoInfo();
            if (!repoInfo) {
                console.error("Error: Repository information could not be retrieved.");
                return;
            }

            const { owner, repo } = repoInfo;

            const existingPrs = await this.gitHubClient.listPulls(owner, repo, baseBranch, compareBranch);

            if (existingPrs.length > 0) {
                const prNumber = existingPrs[0].number;
                console.log(`Updating existing PR #${prNumber}...`);
                await this.gitHubClient.updatePull(owner, repo, prNumber, prTitle, prBody);
            } else {
                console.log("Creating a new PR...");
                const response = await this.gitHubClient.createPull(owner, repo, baseBranch, compareBranch, prTitle, prBody);
                await this.openUrl(response.url);
            }
        } catch (error: any) {
            console.error(`Error creating PR: ${error.message}`);
        }
    }

    async getRepoInfo() {
        try {
            const repoUrl = await this.git.raw(['config', '--get', 'remote.origin.url']);
            const match = repoUrl.match(/github\.com[:/](.+?)\/(.+?)\.git/);
            if (match) {
                return { owner: match[1], repo: match[2] };
            }
        } catch (error: any) {
            console.error(`Failed to get repo info`);
        }
    }

    async getNewFiles(baseBranch: string, compareBranch: string) {
        try {
            const outcome = await this.git.diff(['--diff-filter=A', baseBranch, compareBranch, '--', '.', ...this.exclusions]);
            return outcome;
        } catch (error: any) {
            console.error(`Error getting new files: ${error.message}`);
        }
    }

    async getDiff(baseBranch: string, compareBranch: string) {
        try {
            const outcome = await this.git.diff([baseBranch, compareBranch, '--', '.', ...this.exclusions]);
            return outcome;
        } catch (error: any) {
            console.error(`Error getting diff: ${error.message}`);
        }
    }

    async getFilenames(baseBranch: string, compareBranch: string) {
        try {
            const outcome = await this.git.diff(['--name-only', baseBranch, compareBranch, '--', '.']);
            return outcome;
        } catch (error: any) {
            console.error(`Error getting filenames: ${error.message}`);
        }
    }

    async differ(baseBranch = 'develop', compareBranch: string) {
        try {
            compareBranch = compareBranch || (await this.git.revparse(['--abbrev-ref', 'HEAD'])).trim();

            const textPrompt = prompt;

            const diff = await this.getDiff(baseBranch, compareBranch);
            const newFiles = await this.getNewFiles(baseBranch, compareBranch);
            const filenames = await this.getFilenames(baseBranch, compareBranch);

            if (!diff && !newFiles) {
                return "No changes found between the specified branches.";
            }

            const finalPrompt = `${textPrompt}${diff}\n\n${newFiles}\n\nFilenames:\n${filenames}`;
            const response = await this.gptCall(finalPrompt);
            return response;
        } catch (error: any) {
            console.error(`Error generating PR body: ${error.message}`);
        }
    }

    async gptCall(prompt: string) {
        try {
            const response = await this.openai.completions.create({
                model: 'gpt-4-turbo',
                prompt: prompt,
                max_tokens: 1500,
                n: 1,
                stop: null,
                temperature: 0.2
            });

            return response.data.choices[0].text.trim();
        } catch (error: any) {
            console.error(`Error calling OpenAI API: ${error.message}`);
        }
    }
}

export default PrBot;
/* --- End of ./src/index.ts --- */

/* --- Start of ./test/prbot.test.ts --- */
import { expect } from 'chai';
import * as nock from 'nock';
import * as sinon from 'sinon';
import simpleGit from 'simple-git';
import PrBot from '../src/index';
import proxyquire from 'proxyquire';
import { githubClient, GithubClient } from './githubClient';

import { ChildProcess } from 'child_process';


describe('PrBot', () => {
    let prBot: PrBot;
    let openaiStub: sinon.SinonStub;
    let openUrlStub: sinon.SinonStub;
    let gitStub: sinon.SinonStub;
    let createPRStub: sinon.SinonStub;
    let listPRsStub: sinon.SinonStub;

    beforeEach(() => {
        openUrlStub = sinon.stub().resolves({} as ChildProcess);
        const { PrBot } = proxyquire('../src/index', {
            '../src/openWrapper': { openUrl: openUrlStub }
        });

        prBot = new PrBot('fake-openai-api-key', 'fake-github-token');
        openaiStub = sinon.stub(prBot.openai.completions, 'create');
        createPRStub = sinon.stub(githubClient, 'createPR');
        listPRsStub = sinon.stub(githubClient, 'listPRs');
    });

    afterEach(() => {
        sinon.restore();
        nock.cleanAll();
    });

    describe('Constructor', () => {
        it('should throw an error if OPENAI_API_KEY is not set', () => {
            //@ts-expect-error
            expect(() => new PrBot(null, 'fake-github-token')).to.throw("Error: OPENAI_API_KEY is not set");
        });

        it('should throw an error if GITHUB_TOKEN is not set', () => {
            //@ts-expect-error
            expect(() => new PrBot('fake-openai-api-key', null)).to.throw("Error: GITHUB_TOKEN is not set");
        });
    });

    describe('openUrl', () => {
        it('should open a URL', async () => {
            await prBot.openUrl('http://example.com');
            expect(openUrlStub.calledOnceWith('http://example.com')).to.be.true;
        });

        it('should handle error when opening a URL', async () => {
            openUrlStub.rejects(new Error('Failed to open URL'));
            sinon.stub(console, 'error');
            try {
                await prBot.openUrl('http://example.com');
            } catch (error) {
                expect(openUrlStub.calledOnceWith('http://example.com')).to.be.true;
            }
        });
    });

    describe('getRepoInfo', () => {
        it('should get repository info', async () => {
            sinon.stub(prBot.git, 'raw').resolves('git@github.com:owner/repo.git\n');
            const repoInfo = await prBot.getRepoInfo();
            expect(repoInfo).to.deep.equal({ owner: 'owner', repo: 'repo' });
        });

        it('should handle error when getting repository info', async () => {
            const gitStub = sinon.stub(prBot.git, 'raw').rejects(new Error('Failed to get repo info'));
            const consoleErrorStub = sinon.stub(console, 'error');
            const repoInfo = await prBot.getRepoInfo();
            expect(repoInfo).to.be.undefined;
            expect(consoleErrorStub.calledWith('Failed to get repo info')).to.be.true;
        });
    });

    describe('getNewFiles', () => {
        it('should get new files', async () => {
            const gitStub = sinon.stub(prBot.git, 'diff').resolves('diff --git a/file.txt b/file.txt\n');
            const result = await prBot.getNewFiles('develop', 'feature-branch');
            expect(gitStub.calledOnceWith(['--diff-filter=A', 'develop', 'feature-branch', '--', '.', ...prBot.exclusions])).to.be.true;
            expect(result).to.equal('diff --git a/file.txt b/file.txt\n');
        
        });

        it('should handle error when getting new files', async () => {
            const errorMessage = 'Failed to get new files';
            const gitStub = sinon.stub(prBot.git, 'diff').rejects(new Error(errorMessage));
            const consoleErrorStub = sinon.stub(console, 'error');
            const newFiles = await prBot.getNewFiles('develop', 'feature-branch');
            expect(gitStub.calledOnceWith(['--diff-filter=A', 'develop', 'feature-branch', '--', '.', ...prBot.exclusions])).to.be.true;
            expect(newFiles).to.be.undefined;
            expect(consoleErrorStub.calledWith(`Error getting new files: ${errorMessage}`)).to.be.true;
        });
    });


    describe('getDiff', () => {
        it('should get diff between branches', async () => {
            const baseBranch = 'main';
            const compareBranch = 'feature';
            const diffOutput = 'diff --git a/file1.txt b/file1.txt\nindex 83db48f..f735c2d 100644\n--- a/file1.txt\n+++ b/file1.txt\n@@ -1 +1 @@\n-Hello\n+Hello World\n';
            const gitStub = sinon.stub(prBot.git, 'diff').resolves(diffOutput);
            // sinon.stub(prBot, 'git').get(() => prBot.git); // Ensure prBot uses the stubbed git instance

            const diff = await prBot.getDiff(baseBranch, compareBranch);
            expect(diff).to.equal(diffOutput);
        });

        it('should handle errors', async () => {
            const baseBranch = 'main';
            const compareBranch = 'feature';
            const errorMessage = 'Error getting diff';
            const gitStub = sinon.stub(prBot.git, 'diff').rejects(new Error(errorMessage));
            // sinon.stub(prBot, 'git').get(() => prBot.git); // Ensure prBot uses the stubbed git instance

            const consoleErrorStub = sinon.stub(console, 'error');
            const diff = await prBot.getDiff(baseBranch, compareBranch);
            expect(diff).to.be.undefined;
            expect(consoleErrorStub.calledWith(`Error getting diff: ${errorMessage}`)).to.be.true;
        });
    });
    describe('getFilenames', () => {
        it('should get filenames between branches', async () => {
            const baseBranch = 'main';
            const compareBranch = 'feature';
            const filenamesOutput = 'file1.txt\nfile2.txt\n';
            const gitStub = sinon.stub(prBot.git, 'diff').resolves(filenamesOutput);
            // sinon.stub(prBot, 'git').get(() => PrBot.git); // Ensure prBot uses the stubbed git instance

            const filenames = await prBot.getFilenames(baseBranch, compareBranch);
            expect(filenames).to.equal(filenamesOutput);
        });

        it('should handle errors', async () => {
            const baseBranch = 'main';
            const compareBranch = 'feature';
            const errorMessage = 'Error getting filenames';
            const gitStub = sinon.stub(prBot.git, 'diff').rejects(new Error(errorMessage));
            // sinon.stub(prBot, 'git').get(() => PrBot.git); // Ensure prBot uses the stubbed git instance

            const consoleErrorStub = sinon.stub(console, 'error');
            const filenames = await prBot.getFilenames(baseBranch, compareBranch);
            expect(filenames).to.be.undefined;
            expect(consoleErrorStub.calledWith(`Error getting filenames: ${errorMessage}`)).to.be.true;
        });
    });

    describe('gptCall', () => {
        it('should call OpenAI API', async () => {
            openaiStub.resolves({ data: { choices: [{ text: 'PR body' }] } });
            const response = await prBot.gptCall('prompt');
            expect(response).to.equal('PR body');
            expect(openaiStub.calledOnce).to.be.true;
        });

        it('should handle error when calling OpenAI API', async () => {
            openaiStub.rejects(new Error('Failed to call OpenAI API'));
            sinon.stub(console, 'error');
            const response = await prBot.gptCall('prompt');
            expect(response).to.be.undefined;
            expect(openaiStub.calledOnce).to.be.true;
        });
    });


    describe('githubClient', () => {   
        it('should create a pull request', async () => {
            createPRStub.resolves({ id: 1, title: 'Test PR' });

            const result = await createPullRequest('repo', 'Test PR', 'This is a test PR');
            expect(createPRStub.calledWith('repo', 'Test PR', 'This is a test PR')).to.be.true;
            expect(result).to.deep.equal({ id: 1, title: 'Test PR' });
        });

        it('should list pull requests', async () => {
            listPRsStub.resolves([{ id: 1, title: 'Test PR' }]);

            const result = await listPullRequests('repo');
            expect(listPRsStub.calledWith('repo')).to.be.true;
            expect(result).to.deep.equal([{ id: 1, title: 'Test PR' }]);
        });
    });

    describe('createPr', () => {
        it('should create a new PR', async () => {
            sinon.stub(console, 'log');
            const gitStub = sinon.stub(prBot.git, 'revparse').resolves('feature-branch\n');
            const differStub = sinon.stub(prBot, 'differ').resolves('PR body');
            const getRepoInfoStub = sinon.stub(prBot, 'getRepoInfo').resolves({ owner: 'owner', repo: 'repo' });
            const pullsListStub = sinon.stub(prBot.octokit.pulls, 'list').resolves({ data: [] });
            const pullsCreateStub = sinon.stub(prBot.octokit.pulls, 'create').resolves({ data: { html_url: 'http://example.com' } });
            const openUrlStub = sinon.stub(prBot, 'openUrl').resolves();

            await prBot.createPr('develop');
    
            expect(gitStub.calledOnceWith(['--abbrev-ref', 'HEAD'])).to.be.true;
            expect(differStub.calledOnceWith('develop', 'feature-branch')).to.be.true;
            expect(getRepoInfoStub.calledOnce).to.be.true;
            expect(pullsListStub.calledOnceWith({ owner: 'owner', repo: 'repo', base: 'develop', head: 'feature-branch'})).to.be.true;
            expect(pullsCreateStub.calledOnce).to.be.true;
            expect(openUrlStub.calledOnceWith('http://example.com')).to.be.true;
        });

        it('should update an existing PR', async () => {
            sinon.stub(console, 'log');
            const gitStub = sinon.stub(prBot.git, 'revparse').resolves('feature-branch\n');
            const differStub = sinon.stub(prBot, 'differ').resolves('PR body');
            const getRepoInfoStub = sinon.stub(prBot, 'getRepoInfo').resolves({ owner: 'owner', repo: 'repo' });
            const pullsListStub = sinon.stub(prBot.octokit.pulls, 'list').resolves({ data: [{ number: 1 }] });
            const pullsUpdateStub = sinon.stub(prBot.octokit.pulls, 'update').resolves();

            await prBot.createPr('develop');

            expect(gitStub.calledOnceWith(['--abbrev-ref', 'HEAD'])).to.be.true;
            expect(differStub.calledOnceWith('develop', 'feature-branch')).to.be.true;
            expect(getRepoInfoStub.calledOnce).to.be.true;
            expect(pullsListStub.calledOnceWith({ owner: 'owner', repo: 'repo', base: 'develop', head: 'feature-branch' })).to.be.true;
            expect(pullsUpdateStub.calledOnce).to.be.true;
        });
    });
});
/* --- End of ./test/prbot.test.ts --- */

/* --- Start of ./bin/prbot.ts --- */
#!/usr/bin/env node

import PrBot from '../src/index.js'; // Adjust the path to where your PrBot class is located
import dotenv from 'dotenv';

// Load environment variables from a .env file if it exists
dotenv.config();

const openaiApiKey = process.env.OPENAI_API_KEY;
const githubToken = 'yes'//process.env.GITHUB_TOKEN;
console.log(openaiApiKey, githubToken)
if (!openaiApiKey || !githubToken) {
    console.error("Error: OPENAI_API_KEY and GITHUB_TOKEN must be set in the environment variables.");
    process.exit(1);
}

const prBot = new PrBot(openaiApiKey, githubToken);

const args = process.argv.slice(2);
const baseBranch = args[0] || 'develop';
const compareBranch = args[1];

prBot.createPr(baseBranch, compareBranch).catch((error:any) => {
    console.error(`Error creating PR: ${error.message}`);
    process.exit(1);
});/* --- End of ./bin/prbot.ts --- */

